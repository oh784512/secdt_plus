
from entity2_secdt import ModelOwner, CloudServiceProvider, CloudServiceUser

from secure import param, prime, pseudo_random_generator, rand_num#, GF
import numpy as np
#import galois
import random
import sympy as sy
from Crypto.Util.number import inverse

class ModelOwnerVer2(ModelOwner):
    def __init__(self):
        super().__init__()

    ## SecDT plus Ver.2
    def input_model_and_gen_plusV2_shares(self, root_node, attri_list): 
        '''[+Ver.2] Generate matrix A, invertible matrix S, Aï¼ŽS^-1 = K'''
        self._root_node = root_node
        n = len(attri_list)

        ## Generate attribute permutation matrix A, fixed sequence vb, vb_shuffle
        matrix_A = np.zeros((n,n), dtype=int)
        
        attri_idx_tuple_list = list(enumerate(attri_list))
        random.shuffle(attri_idx_tuple_list)
        indices, l = zip(*attri_idx_tuple_list)
        vb_shuffle_idx = indices
        for i in range(n):
            matrix_A[i][vb_shuffle_idx[i]] = 1
        self.vb = attri_list
        #print("matrix_A: ", matrix_A)

        ## Generate invertible matrix S
        self.matrix_S = np.random.randint(prime(), size=(n, n))
        diagonal_v = np.sum(self.matrix_S, axis=1)
        np.fill_diagonal(self.matrix_S, diagonal_v)
        ####### 
        matrix_S_inverse = np.linalg.inv(self.matrix_S)  ########### floating problem ############

        self.matrix_K = np.dot(matrix_A, matrix_S_inverse) % prime()
        #print("A dot inverseS dot S: ", np.dot(self.matrix_K, self.matrix_S)% prime())

        ## Transform numpy to sympy: A, S, inverse_S, K
        sym_matrix_A = sy.Matrix(matrix_A) ## sym.Matrix get entity: Matrix[i, j]
        self.sym_matrix_S = sy.Matrix(self.matrix_S)
        #self.sym_matrix_S = self.sym_matrix_S % prime()
        #print("sym_matrix_S: ", self.sym_matrix_S)

        sym_S_inv = self.sym_matrix_S.inv(method="LU") ###### fraction number need to transfer to Modular multiplicative inverse
        #print("sym_S_inv: ", sym_S_inv)

        ####### test inverse matrix generated by each entity inverse
        temp_denominator_inv = sy.Matrix.zeros(n, n)
        for i in range(n):
            for j in range(n):
                temp_denominator_inv[i, j] = ((sym_S_inv[i, j].p % prime()) * inverse(int(sym_S_inv[i, j].q), prime())) % prime()
                #temp_denominator_inv[i, j] = (inverse(int(matrix_A[i][j]), prime())) % prime()
        sym_S_inv = temp_denominator_inv

        #inverse(denominator, prime())
        ## test matrix_S dot0 inverse of matrix_S
        #print("sym_S_inv dot sym_matrix_S: ", (self.sym_matrix_S @ sym_S_inv) % prime())
        #self.sym_matrix_K = (sym_matrix_A @ sym_S_inv) % prime()
        #print("prime: ", prime())
        #self.sym_matrix_K = (sym_matrix_A @ sym_S_inv)# % prime()
        self.sym_matrix_K = (sym_matrix_A @ sym_S_inv) % prime()
        #print("sym_matrix_K: ", self.sym_matrix_K)

        #print("K dot S: ", (self.sym_matrix_K @ self.sym_matrix_S) )

        # vt = sy.Matrix([random.randint(prime()-5, prime()+5) for i in range(n)])
        # #vt = sy.Matrix([i for i in range(n)])
        # #print("test vector-vt: ", vt)
        # #S_vt = (self.sym_matrix_S @ vt)# % prime()
        # S_vt = (self.sym_matrix_S @ vt) % prime()
        # #print("S dot vt: ", S_vt)
        # K_ = sym_matrix_A @ sym_S_inv
        # #K_S_vt = (K_ @ S_vt)# % prime()
        # K_S_vt = (K_ @ S_vt) % prime()
        # #print("K dot (S dot vt): ", K_S_vt)

        self.vb = attri_list
        self._plus_transform_attri_to_index(l, attri_list)

        self.split_model_into_shares()
        
    def set_shares_to_two_parties_plusV2(self, csu, csp):
        '''[+Ver.2]'''
        self.set_shares_to_two_parties(csu, csp)
        #csu.set_plusV2_shares_to_two_parties(self.matrix_S, self.vb)
        csu.set_plusV2_shares_to_two_parties(self.sym_matrix_S, self.vb)
        #csp.set_plusV2_shares_to_two_parties(self.matrix_K)
        csp.set_plusV2_shares_to_two_parties(self.sym_matrix_K)
        return


class CloudServiceProviderVer2(CloudServiceProvider):
    def __init__(self):
        super().__init__()

    def set_plusV2_shares_to_two_parties(self, matrix_K):
        '''[+Ver.2]'''
        self.matrix_K = matrix_K

    def set_query_data_plusV2(self, qData_l_S):
        '''[+Ver.2]'''
        #print("matrix_K: ", self.matrix_K)
        #print("qData_l_S: ", qData_l_S)
        #self.qData_A_l = np.dot(self.matrix_K, qData_l_S) % prime()
        #self.qData_A_l = (self.matrix_K @ qData_l_S)# % prime()
        self.qData_A_l = (self.matrix_K @ qData_l_S) % prime()


class CloudServiceUserVer2(CloudServiceUser):
    def __init__(self):
        super().__init__()

    ## SecDT plus Ver.2
    def set_plusV2_shares_to_two_parties(self, matrix_S, vb):
        '''[+Ver.2]'''
        self.matrix_S = matrix_S
        #print("matrix_S: ", self.matrix_S)
        self.vb = vb
    
    def set_query_data_plusV2(self, qData):
        '''[+Ver.2]'''
        self.qData = qData

        #largest_data = max(qData)
        #self.l = random.randint(0, prime() - largest_data - 1)
        self.l = 20

        qData_added_randN = (qData + self.l) % prime()
        #print("l: ", self.l)
        #print("set_query_data_plusV2 qData_added_randN: ", qData_added_randN)
        #self.qData_l_S = np.dot(self.matrix_S, qData_added_randN) % prime()
        
        self.qData_l_S = (self.matrix_S @ qData_added_randN) % prime()

    def send_query_data_to_csp_plusV2(self, csp):
        '''[+Ver.2]'''
        csp.set_query_data_plusV2(self.qData_l_S)